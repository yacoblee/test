'use strict';

/* 
    프라미스 객체는 기본적으로 콜백함수를 인자로 받고
    이를 executor(실행자) 함수라 지칭하며, 해당 함수는
    프라미스 객체 생성과 동시에 동기적으로 바로 실행되는
    특성.
*/
new Promise(() => {
    console.log('executor : 실행자 콜백함수');
});

console.log('=======================================');

/* 
    < resolve, reject 인자 > 

- 콜백함수인 실행자 함수에는 기본적으로 resolve, reject 매개변수가
  제공되는데, 각각 실행에 대한 성공과 실패 처리가 가능한 콜백함수의
  참조로써, 성공, 실패 함수의 콜백 호출시의 실인수 전달이 then 메서드의
  실인수에 정의한 콜백함수의 매개변수로 전달이 가능.
  프라미스는 실행자 내에서 반드시 성공 또는 실패 둘 중 하나만 실행이
  가능하며, 중복 처리는 불가.
  즉, 성공(resolve) 이후에 또다른 성공이나 실패가 처리되지 않는
  것처럼 실패(reject) 이후에도 또다른 실패나 성공은 실행되지 않음.
  성공과 실패는 반드시 모두 명시해야하는 것은 아니며, 성공 또는
  실패만 개별적으로 명시해도 무방.
  단, 이전의 then 에서 성공 또는 실패가 결정되지 않은 상태에서 반환을
  받아 성공, 실패 처리를 다음 then 메서드에 모두 명시하면 최초 성공에
  대한 콜백 처리가 실행됨에 주의.

===================================================================

    < then 메서드 >

- 프라미스 객체의 실행자에서 resolve, reject 함수로 호출되어 전달된
  값을 받아 실행할 수 있는 함수로써, then 메서드의 실인수로 전달한
  콜백함수는 then 메서드에 의해 비동기 콜백 실행되는 특성.
  단, 이는 비동기적으로 실행되는 콜백함수에 한하며, 콜백함수는 동기
  코드는 동기적 특성 그대로 실행되는 것을 확인 가능.
  첫 번째 인자는 성공에 대한 콜백 함수를 정의하고, 두 번째 인자는
  실패에 대한 콜백 함수를 정의.
  또한, then 메서드의 콜백 실행은 모든 동기 코드가 완료된 이후 비동기적
  으로 실행되는 것을 확인 가능.
*/
new Promise((resolve, reject) => {
    resolve('성공');
    reject('실패');
}).then(
    result => console.log(result),
    err => console.log(err)
);
// 비동기로 처리할 경우 then이 바로 찍히지 않고 코드가 실행이 다 끝나고 찍히기 때문에 54번째 코드가 실행 후 
// 찍히게 됨

console.log('=======================================');

/* 
    < 성공만 처리하는 경우 >

- then 메서드의 실인수에 매개변수를 지정하지 않은 상태의 콜백 호출할
  참조만 전달하여도 기본적으로 resolve, reject 함수로 호출시의 실인수
  값을 자동으로 끌고와 콜백 호출시 실인수로 사용됨을 확인 가능.
  성공만 처리하는 연속적인 then 체인 연산에서는 어느 하나라도 실패가
  반환되면 그 시점을 기준으로 더 이상의 then 체인 연산이 진행되지 않음.
*/

new Promise(resolve => {
    resolve('성공');
})
    .then(console.log) //주소만 가져오기 때문에 위에 선언되어 있는 매소드의 주소부에 있는 '성공'을 가져옴
    .then(console.log('동기실행1'));        // then 메서드에 콜백함수의 참조가 아닌 일반 동기 코드를
//                              // 적시하였으므로 동기적으로 그대로 실행.

console.log('=======================================');

/* 
    < 실패만 처리하는 경우 - then >

- Promise 객체 실행자 함수의 첫 번째 인수(resolve)는 생략하거나
  null 값으로 대체 불가하지만, then 메서드의 첫 번째 실인수는
  null 값으로 대체 가능.
  즉, 실패만 처리하는 경우 then 메서드의 첫 번째 인수에 null 값
  할당.
*/

new Promise((resolve, reject) => {
    reject('실패'); //실패에 대한 전달
}).then(
    null, // 성공 값을 비울수 없어서 null로 반환
    console.log //주소부만 반환하는 비동기 처리, 콜백함수로 동작
).then(
    console.log('동기실행2') //동기처리 하기때문에 우선 실행함, 콜백함수 일 경우엔 성공부를 null이나 따로 
    //문법적으로 명시해야 하지만 콜백함수가 아니라 실행 함수이기 때문에 성공,실패를 둘다 명시하지 않아도 됨
);

/* 
    < 실패만 처리하는 경우 - catch>

- catch 메서드는 실패만 다루는 경우 then 을 대체하여 사용 가능한
  메서드로써, then 과 같이 첫 번째 인자에 null 값 할당하는 처리가
  필요없음.
  또한 성공만 처리하는 연속된 then 체인 연산의 끝단에 catch 메서드를
  적용함으로써, 순차적으로 실행되는 then 체인 메서드 내에서 실패가
  반환하면 그 시점에서 이후의 then 메서드를 무시하고 catch 메서드로
  점핑하여 실패에 대한 처리가 가능. 
*/

new Promise((resolve, reject) => {
    reject('실패');
}).catch(console.log);

console.log('=======================================');

/* 
    < finally 메서드 >

- finally 메서드는 예외 처리와 같이 성공, 실패 결과에 관계없이
  공통적인 처리가 가능한 메서드로써, finally 메서드의 인자로
  들어가는 콜백함수에는 매개변수가 없음에 주의.
  따라서 성공 또는 실패에 대한 실인수 값을 전달해도 finally 메서드
  의 매개변수에서는 데이터 수신이 불가.
  또한 프라미스 객체에 대한 then 또는 finally 메서드 호출의 결과는
  프라미스 객체의 실행자 함수 결과를 가지고 있는 프라미스 객체가
  다시 반환되므로 호출 순서는 관계가 없음.
*/
new Promise((resolve, reject) => {
    resolve('성공');
    reject('실패');
})
    .then(
        result => console.log(result),
        err => console.log(err),
    )
    .finally(
        () => console.log('성공, 실패와 무관한 공통 처리')
    );